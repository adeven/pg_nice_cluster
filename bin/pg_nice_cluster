#!/usr/bin/env ruby 

require "pg"
require 'trollop'

opts = Trollop::options do
    opt :db, "database name", :type => :string
    opt :user, "user name", :type => :string, :default => "postgres"
    opt :pass, "password", :type => :string
    opt :host, "host name", :type => :string, :default => "localhost"
    opt :tmp_prefix, "prefix for the temporary tables and indexes (default 'cluster')", :type => :string, :default => "cluster"
    opt :min_size, "cut off size for small tables in mb", :default => 100
end

Trollop::die :db, "database name must be given" if opts[:db] == nil

conn = PG.connect( dbname: opts[:db], host: opts[:host], user: opts[:user], password: opts[:password] )

puts "Connected to Database #{opts[:db]} on #{opts[:host]} as user #{opts[:user]}"

@tables = []

conn.exec( "select relname from pg_stat_user_tables WHERE schemaname='public'" ) do |result|
  result.each do |row|
    @tables << row.values_at('relname').first
  end
end

puts "Found #{@tables.size} Tables..."

@totalsize_before = 0

@tables.each do |table|
    conn.exec( "select pg_total_relation_size('#{table}');" ) do |result|
        size = result.first['pg_total_relation_size'].to_i
        unless size > opts[:min_size] * 1024 * 1024
            @tables.delete(table)
        else
            @totalsize_before += size
        end
    end
end

puts "#{@tables.size} of them are bigger than #{opts[:min_size]} MB including indexes..."
puts "they occupy #{@totalsize_before/(1024*1024)} MB..."

@tables.each do |table|
    puts "starting to cluster #{table}..."

    puts "fetching indexes..."
    @indexes = {}
    @cluster_index = nil

    conn.exec( "select indexname, indexdef from pg_indexes where tablename = '#{table}'" ) do |result|
      result.each do |row|
        @indexes[row.values_at('indexname').first] = row.values_at('indexdef').first
      end
    end
    if @indexes.size == 0
        puts "no index found skipping..."
        next
    else
        puts "found #{@indexes.size} indexes..."
    end

    sql = <<-SQL
            SELECT               
              i.relname
            FROM pg_index, pg_class i, pg_class t, pg_attribute 
            WHERE 
              t.oid = '#{table}'::regclass AND
              indrelid = t.oid AND
              pg_attribute.attrelid = t.oid AND 
              pg_attribute.attnum = any(pg_index.indkey)
              AND indisprimary
              AND i.oid = pg_index.indexrelid;
        SQL

    conn.exec(sql) do |result|
        result.each do |row|
            @cluster_index = result.first['relname']
        end
    end 

    if @cluster_index
        puts "found primary index: using for clustering..."
    else 
        puts "no primary index found: searching for most used btree index"
    end


    unless @cluster_index
        highest_num_of_scans = -1
        @indexes.each do |idx_name, command|
            if command.match("USING btree")
                #if it is a btree go and check no of scans
                conn.exec( "select idx_scan from pg_stat_all_indexes where indexrelname = '#{idx_name}'" ) do |result|
                    scans = result.first['idx_scan'].to_i
                    if scans > highest_num_of_scans
                        highest_num_of_scans = scans
                        @cluster_index = idx_name
                    end
                end
            end
        end
    end

    @triggers = []
    conn.exec( "select * from information_schema.triggers where event_object_table = '#{table}'" ) do |result|
      result.each do |row|
        trigger = [
                    "CREATE TRIGGER",
                    row.values_at('trigger_name').first,
                    row.values_at('action_timing').first,
                    row.values_at('event_manipulation').first,
                    "ON",
                    table,
                    "FOR EACH",
                    row.values_at('action_orientation').first,
                    row.values_at('action_statement').first,
                    ";"
        ]
        @triggers << trigger.join(" ")
      end
    end

    puts "start to cluster #{table} using #{@cluster_index}"
    prefix = opts[:tmp_prefix]

    sql = []
    sql << "BEGIN;"
    sql << "LOCK TABLE #{table} IN EXCLUSIVE MODE;"
    sql << "CREATE TABLE #{prefix}_#{table} AS TABLE #{table};"
    @indexes.each do |idx_name, command|
        sql << command.gsub(" #{idx_name} ", " #{prefix}_#{idx_name} ").gsub("ON #{table} ", "ON #{prefix}_#{table} ") + ";"
    end
    sql << "CLUSTER #{prefix}_#{table} USING #{prefix}_#{@cluster_index};"
    sql << "DROP TABLE #{table};" 
    sql << "ALTER TABLE #{prefix}_#{table} RENAME TO #{table};"
    @indexes.each do |idx_name, command|
        sql << "ALTER INDEX #{prefix}_#{idx_name} RENAME TO #{idx_name};"
    end
    @triggers.each do |trigger|
        sql << trigger
    end
    sql << "COMMIT;"

    conn.exec(sql.join("\n"))
    puts sql.join("\n")
    puts "Successfully clustered #{table}!"    
end

puts "Finished clustering Database #{opts[:db]}"
@totalsize_after = 0

@tables.each do |table|
    conn.exec( "select pg_total_relation_size('#{table}');" ) do |result|
        size = result.first['pg_total_relation_size'].to_i
        if size > opts[:min_size] * 1024 * 1024
            @totalsize_after += size
        end
    end
end
puts "The #{@tables.size} Tables now occupy #{@totalsize_before/(1024*1024)} MB!"